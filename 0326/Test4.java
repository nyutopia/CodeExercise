/*
Given a binary tree,
 find its minimum depth.
 The minimum depth is the number of nodes
 along the shortest path from the root node down to the nearest leaf node.
*/
本题要注意最小深度与最大深度的区别：
对于最大深度，不需要考虑当前子树是否为单子树（即一侧子树深度为0）的情况，
即最大深度一直等于左右子树的最大值；
对于最小深度，需要考虑当前子树是否为单子树的情况，
对于双子树，
其最小深度为左右子树的最小值，对于单子树，其最小深度为左右深度的最大值（因为有一侧的子树为0）。
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
 
public class Test4{
    public int run(TreeNode root) {
        return getShortestDepth(root);
    }
    public int getShortestDepth(TreeNode root){
        if(root == null) return 0;
        if(root.right==null) return getShortestDepth(root.left)+1;
        if(root.left == null) return getShortestDepth(root.right)+1;
        return Math.min(getShortestDepth(root.left),getShortestDepth(root.right))+1;
        
    }
}


/*
题目描述
输入一棵二叉树，求该树的深度。
从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，
最长路径的长度为树的深度。
*/

/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/      
public class Test2{
    public int TreeDepth(TreeNode root) {
        if(root == null) return 0;
        
        int left = TreeDepth(root.left);
        int right = TreeDepth(root.right);
        
        return (left>right)?left+1:right+1;
    }
}