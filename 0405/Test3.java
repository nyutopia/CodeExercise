
 /*
 * 基本的0-1背包问题：
 * 已知有N类物品，每类物品都只有一件，对应的重量为w[i],价值为v[i]。
 * 背包最多承重为W，在不超出承重范围的前提下，求能拿的物件的最大价值为多少
 *
 *这是DP的一个经典实例，可以用动态规划求解
 *设dp(i,j)表示对于前i件物品，背包容量为j时，能取得的最大价值
 *状态转移方程：dp(i,j) = Max(dp(i-1,j), dp(i-1,j-w[i])+v[i])
 *注：   dp(i-1,j)          -----》                dp(i,j)，即不拿第i件物品
 *   dp(i-1,j-w[i])     -----》                dp(i,j)，即拿第i件物品
  
 * 当物品数量很多，背包的容量很大时,这时要用二维数组往往是不现实的
 * 我们可以进行空间压缩，使用一维数组实现
 * 状态转移方程：
 * dp(j)=Max(dp(j),dp(j-w[i])+v[i])
 * 注：对于背包的容量要采用倒序的方式！
 */
 
/*
 * 二维背包问题：
 * 对于每件物品,当选择这件物品必须同时付出两种代价；
 * 对于每种代价都有一个可付出的最大值（背包容量）。
 * 问怎样选择物品可以得到最大的价值。
 * 设第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为u和v。物品的价值为w[i]。
 * 状态转移方程：dp[i][u][v] = max(dp[i-1][u][v] , w[i] + dp[i-1][u-a[i]][v-b[i]])
 *
 * 同样的进行空间压缩，我们可以得到二维数组的状态转移方程，如下：
 * dp[u][v] = max(dp[u-a[i]][v-b[i]]+w[i],dp[u][v])
 * 注：u、v在此均采用倒序！
 *
 * 例题说明：
 * 众所周知计算机代码底层计算都是0和1的计算，牛牛知道这点之后就想使用0和1创造一个新世界！
 * 牛牛现在手里有n个0和m个1，给出牛牛可以创造的x种物品，每种物品都由一个01串表示。
 * 牛牛想知道当前手中的0和1可以最多创造出多少种物品。
 * 等价对应：
 * n                ---------           背包容量，u
 * m                ---------           背包容量，v
 * x                ---------           物品个数
 * item[i].0的个数 ---------           物品i对应u部分的容量
 * item[i].1的个数 ---------           物品i对应v部分的容量
 * 最多创造的物品种数    ---------           可得到的最大价值（此时物品的价值w[i]=1）
 */
 
 //另外常见的还有完全背包问题以及多重背包问题，就不嗦了，花点时间，至少在理解上，问题应该不是很大
 //感觉难的还是怎么把一个题目抽象到对应背包问题的模型上来，以及相关代码实现的优化。

/*
众所周知计算机代码底层计算都是0和1的计算，牛牛知道这点之后就想使用0和1创造一个新世界！牛牛现在手里有n个0和m个1，给出牛牛可以创造的x种物品，每种物品都由一个01串表示。牛牛想知道当前手中的0和1可以最多创造出多少种物品。 
输入描述:
输入数据包括x+1行：

第一行包括三个整数x(2 ≤ x ≤ 20)，n(0 ≤ n ≤ 500)，m(0 ≤ m ≤ 500)，以空格分隔

接下来的x行，每行一个01串item[i]，表示第i个物品。每个物品的长度length(1 ≤ length ≤ 50)


输出描述:
输出一个整数，表示牛牛最多能创造多少种物品

输入例子:
3 3 1
1
00
100

输出例子:
2
*/

import java.util.Scanner;
public class Test3{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int x = sc.nextInt();
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] ones = new int[x];
        int[] zeros = new int[x];
        for(int i = 0;i<x;i++){
            String s = sc.next();
            for(int j = 0;j<s.length();j++){
                if(s.charAt(j)=='1'){
                    ones[i]++;
                }else{
                    zeros[i]++;
                }
            }
        }
        int[][] w = new int[n+1][m+1];
        for(int i=0;i<x;i++){
            for(int u=n;u>=zeros[i];u--){
                for(int v=m;v>=ones[i];v--){
                    if(w[u][v]<w[u-zeros[i]][v-ones[i]]+1){
                        w[u][v]=w[u-zeros[i]][v-ones[i]]+1;
                    }
                }
            }
        }
        System.out.println(w[n][m]);
    }
}